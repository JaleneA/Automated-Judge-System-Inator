package proxy;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;

import proxy.service.ChatBotService;
import servicelocator.StudentService;

/**
 * Proxy implementation for the {@link proxy.service.ChatBotService} interface.
 * <p>
 * This proxy class dynamically loads and invokes methods from the `ChatBot`
 * class of the current student. It interacts with the student's implementation
 * of the chatbot to send prompts, generate responses, and check message limits.
 * The proxy handles reflection-based method invocation, making it possible to
 * work with dynamic and runtime-loaded chatbot classes.
 * <p>
 * The class provides a wrapper around a chatbot instance, providing
 * functionalities such as: prompting the chatbot, retrieving statistics like
 * response count and message limits, and generating responses. The Proxy
 * pattern is used to control access to the real chatbot instance, which is
 * loaded dynamically using Java reflection.
 *
 * @author jalenearmstrong
 * @see <a href="https://refactoring.guru/design-patterns/proxy">Proxy Design
 * Pattern</a>
 * @see <a href="https://www.baeldung.com/java-classloaders">Java Class
 * Loaders</a>
 */
public class ChatBotProxy implements ChatBotService {

    // -- INSTANCE VARIABLES --
    /**
     * The {@code Class} object representing the dynamically loaded chatbot
     * class.
     */
    private Class<?> chatBotClass;

    /**
     * The LLM (Large Language Model) code associated with the chatbot instance.
     */
    private int LLMcode;

    /**
     * The number of messages that have been processed or sent during the
     * current conversation with the chatbot.
     */
    private int messageNumber = 0;

    /**
     * The total number of responses generated by the chatbot.
     */
    private int numResponsesGenerated = 0;

    /**
     * The name of the chatbot.
     */
    private int chatBotName;

    // -- CONSTRUCTORS --
    /**
     * Default constructor for {@code ChatBotProxy}.
     */
    public ChatBotProxy() {
    }

    /**
     * Constructor for {@code ChatBotProxy} that initializes the proxy with a
     * specific LLM code. This constructor loads the corresponding chatbot
     * class.
     *
     * @param LLMcode the code representing the specific chatbot model to be
     * used.
     */
    public ChatBotProxy(int LLMcode) {
        this.LLMcode = LLMcode;
        loadChatBotClass();
    }

    // -- OVERRIDDEN METHODS --
    @Override
    public String prompt(String requestMessage) {
        Object chatBotInstance = createChatBotInstance();
        return (String) invokeMethod(chatBotInstance, "prompt", new Class<?>[]{String.class}, requestMessage);
    }

    @Override
    public String getChatBotName() {
        Object chatBotInstance = createChatBotInstance();
        return (String) invokeMethod(chatBotInstance, "getChatBotName", new Class<?>[]{});
    }

    @Override
    public int getNumResponsesGenerated() {
        Object chatBotInstance = createChatBotInstance();
        return (int) invokeMethod(chatBotInstance, "getNumResponsesGenerated", new Class<?>[]{});
    }

    @Override
    public int getMessageLimit() {
        Object chatBotInstance = createChatBotInstance();
        return (int) invokeMethod(chatBotInstance, "getMessageLimit", new Class<?>[]{});
    }

    @Override
    public boolean limitReached() {
        Object chatBotInstance = createChatBotInstance();
        return (boolean) invokeMethod(chatBotInstance, "limitReached", new Class<?>[]{});
    }

    @Override
    public int getTotalNumResponsesGenerated() {
        return (int) invokeStaticMethod("getTotalNumResponsesGenerated");
    }

    @Override
    public int getTotalNumMessagesRemaining() {
        return (int) invokeStaticMethod("getTotalNumMessagesRemaining");
    }

    @Override
    public String generateResponse() {
        numResponsesGenerated++;
        messageNumber++;
        Object chatBotInstance = createChatBotInstance();
        String response = (String) invokeMethod(chatBotInstance, "generateResponse", new Class<?>[]{});
        return "(Message #" + messageNumber + ") Response from " + getChatBotName() + " >> " + response;
    }

    @Override
    public String toString() {
        Object chatBotInstance = createChatBotInstance();
        String chatBotName = (String) invokeMethod(chatBotInstance, "getChatBotName", new Class<?>[]{});
        int numResponsesGenerated = (int) invokeMethod(chatBotInstance, "getNumResponsesGenerated", new Class<?>[]{});

        return "ChatBot Name: " + chatBotName + "     "
                + "Number Messages Used: " + numResponsesGenerated + "\n";
    }

    // -- HELPER METHODS --
    /**
     * Creates an instance of the chatbot class using the LLM code.
     *
     * @return a new instance of the dynamically loaded ChatBot class.
     * @throws RuntimeException if there is an error creating the instance.
     */
    private Object createChatBotInstance() {
        try {
            return chatBotClass.getDeclaredConstructor(int.class).newInstance(LLMcode);
        } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            throw new RuntimeException("Error creating ChatBot instance with LLM code " + LLMcode, e);
        }
    }

    /**
     * Invokes a method on the chatbot instance using reflection.
     *
     * @param instance the instance of the chatbot to invoke the method on.
     * @param methodName the name of the method to invoke.
     * @param parameterTypes the types of the method's parameters.
     * @param args the arguments to pass to the method.
     * @return the result of the method invocation.
     * @throws RuntimeException if the method invocation fails.
     */
    private Object invokeMethod(Object instance, String methodName, Class<?>[] parameterTypes, Object... args) {
        try {
            return instance.getClass().getMethod(methodName, parameterTypes).invoke(instance, args);
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException("Method invocation failed: " + methodName, e);
        }
    }

    /**
     * Invokes a static method on the dynamically loaded chatbot class.
     *
     * @param methodName the name of the static method to invoke.
     * @return the result of the method invocation.
     * @throws RuntimeException if the static method invocation fails.
     */
    private Object invokeStaticMethod(String methodName) {
        try {
            return chatBotClass.getMethod(methodName).invoke(null);
        } catch (IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            throw new RuntimeException("Error invoking static method " + methodName, e);
        }
    }

    /**
     * Loads the chatbot class dynamically from the student's folder.
     *
     * @throws RuntimeException if the class file cannot be found or loaded.
     */
    private void loadChatBotClass() {
        try {
            String studentName = StudentService.getCurrentStudentName();
            String classFilePath = "src/main/java/students/" + studentName + "/ChatBot.class";
            CustomClassLoader classLoader = new CustomClassLoader();
            this.chatBotClass = classLoader.loadClassFromFile(classFilePath);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("ChatBot class not found at the specified path", e);
        }
    }

    // -- GETTERS --
    public int getLLMcode() {
        return LLMcode;
    }

    // -- SETTERS --
    public void setLLMcode(int LLMcode) {
        this.LLMcode = LLMcode;
    }

    public void setNumResponsesGenerated(int numResponsesGenerated) {
        this.numResponsesGenerated = numResponsesGenerated;
    }

    // -- INNER CLASSES --
    /**
     * Custom class loader to load a class dynamically from the file system.
     */
    private class CustomClassLoader extends ClassLoader {

        /**
         * Loads a class from a file at the specified file path.
         *
         * @param filePath the path to the `.class` file.
         * @return the loaded {@code Class<?>} object.
         * @throws ClassNotFoundException if the class file cannot be loaded.
         */
        public Class<?> loadClassFromFile(String filePath) throws ClassNotFoundException {
            try {
                File classFile = new File(filePath);
                byte[] classData = new byte[(int) classFile.length()];
                try (FileInputStream fis = new FileInputStream(classFile)) {
                    fis.read(classData);
                }
                return defineClass(null, classData, 0, classData.length);
            } catch (IOException e) {
                throw new ClassNotFoundException("Class file not found at: " + filePath, e);
            }
        }
    }
}
